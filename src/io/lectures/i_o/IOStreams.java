package io.lectures.i_o;

public class IOStreams {

    /**
     * InputStream:
     *
     * read() Возвращает текущий доступный символ из
     * входного потока в виде целого значения.
     *
     * read(byte b[]) Читает b.length байт из входного
     * потока в массив b. Возвращает количество
     * прочитанных из потока байт.
     *
     * read(byte b[], int start, int len) Читает len байт из
     * входного потока в массив b, но
     * располагает их в массиве, начиная с
     * элемента start. Возвращает количество
     * прочитанных байт.
     *
     * skip(long n) Пропускает во входном потоке n байт.
     * Возвращает количество пропущенных байт.
     *
     * available() Возвращает количество байт в потоке,
     * доступных для чтения.
     *
     * mark(int readlimit) Ставит метку в текущей позиции
     * входного потока, которую можно
     * Будет использовать до тех пор, пока из
     * потока не будет прочитано readlimit байтов.
     *
     * reset() возвращает указатель потока на
     * установленную ранее метку.
     *
     * markSupported() Возвращает true, если данный поток
     * поддерживает операции mark и reset.
     *
     * close() Закрывает входной поток.
     * <p>
     * <p>
     * <p>
     * OutputStream:
     *
     * write(int b) Записывает один байт в выходной поток.
     *
     * write(byte b[]) Записывает в выходной поток весь
     * указанный массив байтов.
     *
     * write(byte b[], int start, int len) Записывает в
     * поток часть массива – len байтов,
     * начиная с элемента b[start].
     *
     * flush() Очищает выходные буферы
     * буферизированных потоков.
     *
     * close() Закрывает выходной поток.
     *
     * Всегда надо учитывать такие исключения,
     * как IOException (и производное от него исключение
     * FileNotFoundException) и SecurityException.
     *
     * Поэтому отметьте
     * тот факт, что код, использующий ввод-вывод должен заклю-
     * чаться в try-catch блоки. Кроме традиционных try и catch
     * блоков, очень полезно будет использовать необязательный
     * finally блок, в котором удобно будет выполнять обязатель-
     * ное закрытие потоков. Альтернативой этому может быть
     * использование улучшенного блока try с ресурсами:
     *
     * try( resource ){
     *    //IO processing
     * }
     */
    public static void main(String[] args) {

    }

}
